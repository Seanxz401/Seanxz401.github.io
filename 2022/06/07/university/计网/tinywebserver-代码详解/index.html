<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="对tinywebserver总逻辑和各个模块的详细解释。">
<meta property="og:type" content="article">
<meta property="og:title" content="tinywebserver-代码详解">
<meta property="og:url" content="http://example.com/2022/06/07/university/%E8%AE%A1%E7%BD%91/tinywebserver-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Sean&#39;s Blog">
<meta property="og:description" content="对tinywebserver总逻辑和各个模块的详细解释。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/d6QDN5Qn-18ZGAYUuHqhdQ.png">
<meta property="og:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/webserver-listen.png">
<meta property="og:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/D9J8gDW9X7bHghqKvFFILQ.png">
<meta property="og:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/fe9dd1df0fa84dd188fdfecd2e9ec041.jpg">
<meta property="og:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/timer.png">
<meta property="og:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/_3cBGoX9chIM3H0t1oHRmg.jpeg">
<meta property="og:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/qNoC_XNdEYo2n6CXbUau9A.png">
<meta property="og:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/Y_q6fzTjkIOcLxlFm3x3Rg.png">
<meta property="og:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/F1wM4YgOsLk5Bs0MASW3vQ.png">
<meta property="og:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/x7mZnDY4r5Xrtu0LzAP2dg.png">
<meta property="og:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/EoV7MwhIAGlLh9KKOhCTyw.png">
<meta property="article:published_time" content="2022-06-07T00:41:03.000Z">
<meta property="article:modified_time" content="2024-05-27T07:45:59.459Z">
<meta property="article:author" content="Sean">
<meta property="article:tag" content="网络安全 课程笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/d6QDN5Qn-18ZGAYUuHqhdQ.png">

<link rel="canonical" href="http://example.com/2022/06/07/university/%E8%AE%A1%E7%BD%91/tinywebserver-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>tinywebserver-代码详解 | Sean's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Sean's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/06/07/university/%E8%AE%A1%E7%BD%91/tinywebserver-%E4%BB%A3%E7%A0%81%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/banner.jpg">
      <meta itemprop="name" content="Sean">
      <meta itemprop="description" content="热爱可抵岁月漫长">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sean's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          tinywebserver-代码详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-06-07 08:41:03" itemprop="dateCreated datePublished" datetime="2022-06-07T08:41:03+08:00">2022-06-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-27 15:45:59" itemprop="dateModified" datetime="2024-05-27T15:45:59+08:00">2024-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/university/" itemprop="url" rel="index"><span itemprop="name">university</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/university/%E8%AE%A1%E7%BD%91/" itemprop="url" rel="index"><span itemprop="name">计网</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>对tinywebserver总逻辑和各个模块的详细解释。</p>
<span id="more"></span>

<h1 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h1><h2 id="触发模式"><a href="#触发模式" class="headerlink" title="触发模式"></a>触发模式</h2><ul>
<li>LT是指电平触发（level trigger），当IO事件就绪时，内核会一直通知，直到该IO事件被处理；</li>
<li>ET是指边沿触发（Edge trigger），当IO事件就绪时，内核只会通知一次，如果在这次没有及时处理，该IO事件就丢失了。</li>
</ul>
<h2 id="IO复用"><a href="#IO复用" class="headerlink" title="IO复用"></a>IO复用</h2><ul>
<li><p>在单个进程中通过记录跟踪每一个Socket(I&#x2F;O流)的状态来同时管理多个I&#x2F;O流，但它本身是阻塞的。</p>
</li>
<li><p>本项目是利用epoll IO复用技术实现对监听socket（listenfd）和连接socket（客户请求连接之后的socket）的同时监听。</p>
</li>
<li><p>why epoll in select&#x2F;poll&#x2F;epoll:</p>
</li>
<li><ul>
<li>select和poll的最大开销来自内核判断是否有文件描述符就绪这一过程：每次执行select或poll调用时，它们会采用遍历的方式，遍历整个文件描述符集合去判断各个文件描述符是否有活动；epoll则不需要去以这种方式检查，当有活动产生时，会自动触发epoll回调函数通知epoll文件描述符，然后内核将这些就绪的文件描述符放到之前提到的ready list中等待epoll_wait调用后被处理。</li>
<li>当监测的fd数量较小，且各个fd都很活跃的情况下，建议使用select和poll；<strong>当监听的fd数量较多，且单位时间仅部分fd活跃的情况下，使用epoll会明显提升性能</strong>。</li>
</ul>
</li>
</ul>
<h2 id="事件处理模式"><a href="#事件处理模式" class="headerlink" title="事件处理模式"></a>事件处理模式</h2><ul>
<li>Reactor模式：要求主线程（I&#x2F;O处理单元）只负责监听文件描述符上是否有事件发生（可读、可写），若有，则立即通知工作线程，将socket可读可写事件放入请求队列，读写数据、接受新连接及处理客户请求均在工作线程中完成。(需要区别读和写事件)</li>
<li>Proactor模式：主线程和内核负责处理读写数据、接受新连接等I&#x2F;O操作，工作线程仅负责业务逻辑（给予相应的返回url），如处理客户请求。</li>
<li>本项目中使用同步IO模拟proactor模式——线程池部分</li>
</ul>
<h1 id="main-WebServer"><a href="#main-WebServer" class="headerlink" title="main+WebServer"></a>main+WebServer</h1><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><ul>
<li><p>MAX_FD:最大文件描述符（？最大http请求数量）</p>
</li>
<li><p>MAX_EVENT_NUMBER 最大事件数（最大操作请求数量？）</p>
</li>
<li><p>TIMESLOT：最小超时单位</p>
</li>
<li><p>TRIGMode：触发组合模式,默认listenfd LT + connfd LT</p>
</li>
<li><ul>
<li>LISTENTrigmode：listenfd触发模式，默认LT</li>
<li>CONNTrigmode：connfd触发模式，默认LT</li>
</ul>
</li>
<li></li>
<li><p>SOL_SOCKET 指定设置SOCKET的选项</p>
</li>
<li><ul>
<li>SO_LINGER 指定close函数对 面向连接的协议(如TCP)如何操作</li>
<li>SO_REUSEADDR重用处于TIME_WAIT的socket</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><ul>
<li><strong>users</strong>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http_conn * users = new http_conn[MAX_FD];</span><br></pre></td></tr></table></figure>

<p>该连接最多执行MAX_FD个http请求</p>
<ul>
<li><strong>linger</strong>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct linger tmp = &#123;0, 1&#125;|&#123;1，1&#125;;</span><br></pre></td></tr></table></figure>

<p>socket强制退出|优雅断开</p>
<ul>
<li><strong>address</strong>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct sockaddr_in address;</span><br></pre></td></tr></table></figure>

<p>[socket编程——sockaddr_in结构体操作 - 周人假的 - 博客园 (cnblogs.com)](<a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhouhbing/p/3844484.html#:~:text=sockaddr_in">https://www.cnblogs.com/zhouhbing/p/3844484.html#:~:text=sockaddr_in</a> 结构体：struct,sockaddr_in中的in 表示internet，就是网络地址，这只是我们比较常用的地址结构，属于AF_INET地址族，他非常的常用) 给服务器的连接绑定地址和端口</p>
<ul>
<li><strong>events</strong>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br></pre></td></tr></table></figure>

<p>epoll创建内核事件表 <a target="_blank" rel="noopener" href="https://blog.csdn.net/sjin_1314/article/details/8240511">struct epoll_event轻飘风扬的博客-CSDN博客epoll_event结构体</a></p>
<ul>
<li><strong>m_epollfd</strong>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_epollfd = epoll_create(5);</span><br></pre></td></tr></table></figure>

<p>创建一个epoll专用的socket</p>
<ul>
<li><strong>sigaction</strong>:</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction sa;</span><br></pre></td></tr></table></figure>

<p>用来描述对信号的处理 <a target="_blank" rel="noopener" href="https://blog.csdn.net/weibo1230123/article/details/81411827">linux中sigaction函数详解魏波-的博客-CSDN博客sigaction</a></p>
<ul>
<li>**client_data *users_timer;**sockaddr_in+uti_timer</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>WebServer()构造函数</p>
</li>
<li><p>users（http_conn类）：数组，定义了http连接的最大连接数</p>
</li>
<li><p>m_root（WebServer类）：html的路径</p>
</li>
<li><ul>
<li>users_timer（client_data类）：给每个用户连接分配一个定时器</li>
<li>sql_pool()初始化mysql连接，获得</li>
<li>m_connPool（connection_pool类）连接池中的一条连接</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">users-&gt;initmysql_result(m_connPool);</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>通过读取user表测试连接</li>
<li>thread_pool()</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_pool = new threadpool&lt;http_conn&gt;()</span><br></pre></td></tr></table></figure>

<p>- </p>
<ul>
<li><p>**eventListen()**对服务端socket的一些预处理</p>
</li>
<li><p><strong>socket()</strong>:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m_listenfd = socket(PF_INET, SOCK_STREAM, 0);</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><p>新建一个socket监听</p>
</li>
<li><ul>
<li>协议族PF_INET：IPv4</li>
<li>socket类型SOCK_STREAM：TCP连接</li>
<li>指定协议：当protocol为0时，会自动选择type类型对应的默认协议。</li>
<li>**setsockopt()**设置socket选项： <a target="_blank" rel="noopener" href="https://blog.csdn.net/zhizhengguan/article/details/111553079">Linux C&#x2F;C++编程：setsockopt、getsockopt_OceanStar的学习笔记的博客-CSDN博客_getsockopt linux</a></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li><p>设置socket的断开方式，根据linger tmp</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(m_listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, sizeof(tmp));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><p>设置重用socket</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setsockopt(m_listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;flag, sizeof(flag));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>bind()</strong>:</p>
</li>
<li><ul>
<li><p>绑定监听socket</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = bind(m_listenfd, (struct sockaddr *)&amp;address, sizeof(address));</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>listen()</strong>:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret = listen(m_listenfd, 5);</span><br></pre></td></tr></table></figure>

<p>server开始监听指定socket的活动，设置最大排队数为5</p>
<ul>
<li><ul>
<li><p><strong>utils.init(TIMESLOT)</strong>:定时器设置最小超时单位</p>
</li>
<li><p><strong>utils.addfd()</strong></p>
</li>
<li><ul>
<li><p>**epoll_ctl()**用于控制某个文件描述符上的事件，可以注册事件，修改事件，删除事件。addfd中是为该socket设置注册事件</p>
</li>
<li><ul>
<li>EPOLL_CTL_ADD注册、</li>
<li>EPOLL_CTL_MOD修改、</li>
<li>EPOLL_CTL_DEL删除；</li>
</ul>
</li>
<li><p>**setnonblocking()**设置socket为非阻塞</p>
</li>
</ul>
</li>
<li><p>**socketpair()**建立一对匿名的已经连接的套接字????暂时不知道有什么用</p>
</li>
<li><ul>
<li>m_pipefd[2]用来存这一对socket，为m_pipefd[0]添加注册事件，设置m_pipefd[1]为非阻塞</li>
</ul>
</li>
<li><p>**utils.addsig()**添加信号处理</p>
</li>
</ul>
</li>
<li><p>sig_handler()信号处理函数</p>
</li>
<li><ul>
<li>**alarm(TIMESLOT)**设置每隔TIMESLOT的时间就触发SIGALRM信号的函数</li>
</ul>
</li>
<li><p>**dealclinetdata()**处理来自客户端的tcp请求（暂且只看默认模式，即0 &#x3D;&#x3D; m_LISTENTrigmode）</p>
</li>
<li><p><strong>accept()</strong>:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connfd = accept(m_listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br></pre></td></tr></table></figure>

<p>接收客户端的请求，返回一个生成的新的socket（<strong>注意listenfd和connfd都是int类型，表示pid？？？</strong>）</p>
<ul>
<li><ul>
<li><p><strong>timer()</strong></p>
</li>
<li><ul>
<li>**users[connfd].init()**初始化一个http_conn连接</li>
<li><strong>timer</strong>(util_timer类)，<strong>user_data</strong>(client_data类)</li>
<li>创建定时器，设置回调函数和超时时间，绑定用户数据，将定时器添加到<strong>链表</strong>中</li>
</ul>
</li>
</ul>
</li>
<li><p>**dealwithsignal()**处理信号</p>
</li>
<li><ul>
<li><strong>SIGALRM</strong> 超时</li>
<li><strong>SIGTERM</strong>停止server(stop_server &#x3D; true)</li>
</ul>
</li>
<li><p><strong>dealwithread()<strong>处理</strong>读</strong>线程（暂时只看默认模式，即actor_model &#x3D; 0;并发模型,默认是proactor）</p>
</li>
<li><ul>
<li>http_conn-&gt;read_once()</li>
<li>threadpool-&gt;append_p()</li>
</ul>
</li>
<li><p><strong>dealwithwrite()<strong>处理</strong>写</strong>线程（暂时只看默认模式，即actor_model &#x3D; 0;并发模型,默认是proactor）</p>
</li>
<li><p>http_conn-&gt;write()</p>
</li>
<li><ul>
<li>adjust_timer</li>
</ul>
</li>
<li><p>**eventLoop()**正式开始</p>
</li>
<li><p><strong>epoll_wait()</strong>:</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number=epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, -1);</span><br></pre></td></tr></table></figure>

<p>轮询I&#x2F;O事件的发生；</p>
<ul>
<li><ul>
<li><ul>
<li>返回发生的事件数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>main.cpp:</p>
<p>​                 <img src="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/d6QDN5Qn-18ZGAYUuHqhdQ.png" alt="img">        </p>
<p>webserver::eventListen</p>
<p>​       <img src="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/webserver-listen.png" alt="webserver-listen"></p>
<p>webserver::eventLoop</p>
<p>​                 <img src="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/D9J8gDW9X7bHghqKvFFILQ.png" alt="img">        </p>
<h1 id="CGImysql"><a href="#CGImysql" class="headerlink" title="CGImysql"></a>CGImysql</h1><h2 id="模块逻辑：单例模式-RAII机制"><a href="#模块逻辑：单例模式-RAII机制" class="headerlink" title="模块逻辑：单例模式&amp;RAII机制"></a>模块逻辑：单例模式&amp;RAII机制</h2><p><img src="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/fe9dd1df0fa84dd188fdfecd2e9ec041.jpg" alt="img"></p>
<h2 id="变量-1"><a href="#变量-1" class="headerlink" title="变量"></a>变量</h2><ul>
<li>int m_MaxConn   最大连接数</li>
<li>int m_CurConn     当前已使用的连接数</li>
<li>int m_FreeConn   当前空闲的连接数</li>
<li>string m_url           主机地址</li>
<li>string m_Port 数据库端口号</li>
<li>string m_User 登陆数据库用户名</li>
<li>string m_DatabaseName 使用数据库名</li>
<li>string m_PassWord 登陆数据库密码</li>
<li>int m_close_log 日志开关</li>
</ul>
<h2 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>connection::connection_pool()，建立数据库连接池</p>
<ul>
<li><p>初始化未建立连接机当前已使用的连接数和空闲的连接数均为0</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">m_CurConn = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">m_FreeConn = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用以空间换时间的思想，使用连接池的模式初始化多个mysql连接</p>
</li>
</ul>
</li>
<li><p><strong>connection_pool *connection_pool::GetInstance()，建立连接池</strong></p>
<ul>
<li><p>生成数据库连接池，将数据库连接池放入静态栈总</p>
</li>
<li><p><strong>单例模式</strong></p>
<p>采用单例懒汉模式创建连接池，使用信号量表示空闲连接数，管理连接出池入池，并且在入池出池操作前加锁，避免操作冲突。</p>
</li>
</ul>
</li>
<li><p><strong>void connection_pool::init，构造初始化</strong></p>
<ul>
<li><p>初始化连接池，将空闲的连接数m_FreeConn设为初始化获取最大连接数MaxConn</p>
</li>
<li><p><strong>使用信号量sem同步空闲连接数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reserve = sem(m_FreeConn);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>MYSQL *connection_pool::GetConnection()，请求建立一个可用连接</strong></p>
<p>等待空闲信号，上锁，front引用当前列表（先进先出）的第一个元素，……</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reserve.<span class="built_in">wait</span>(); </span><br><span class="line">lock.<span class="built_in">lock</span>();</span><br><span class="line">con = connList.<span class="built_in">front</span>();</span><br><span class="line">connList.<span class="built_in">pop_front</span>();</span><br><span class="line">--m_FreeConn;</span><br><span class="line">++m_CurConn;</span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br></pre></td></tr></table></figure>

<h6 id="补充：为什么要使用互斥锁锁定列表？"><a href="#补充：为什么要使用互斥锁锁定列表？" class="headerlink" title="补充：为什么要使用互斥锁锁定列表？"></a><strong>补充：为什么要使用互斥锁锁定列表？</strong></h6><p>如果多个线程访问单个容器，并且至少有一个线程可能写入，则用户负责确保在容器访问期间线程之间的互斥。</p>
<p>（可能两个线程同时访问，事务错误……）</p>
</li>
<li><p><strong>bool connection_pool::ReleaseConnection(MYSQL *con)，释放当前使用的连接</strong></p>
<p>上锁，push_back将元素添加到容器末尾，（将连接放回连接池）……解锁，post发送sem信号</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lock.<span class="built_in">lock</span>();</span><br><span class="line">connList.<span class="built_in">push_back</span>(con);</span><br><span class="line">++m_FreeConn;</span><br><span class="line">--m_CurConn;</span><br><span class="line">lock.<span class="built_in">unlock</span>();</span><br><span class="line">reserve.<span class="built_in">post</span>();</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>void connection_pool::DestroyPool()，销毁数据库连接池</strong></p>
<p>连接池数据置0，clear清除连接池。</p>
</li>
<li><p><strong>int connection_pool::GetFreeConn()，当前空闲的连接数</strong></p>
</li>
<li><p><strong>connectionRAII::connectionRAII(MYSQL</strong> *<strong>SQL, connection_pool</strong> <strong>connPool)，数据库连接封装</strong></p>
<ul>
<li><strong>在RAII的构造函数中获取连接池中的连接，并将外部MYSQL连接指向该连接</strong></li>
</ul>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SQL = connPool-&gt;<span class="built_in">GetConnection</span>();</span><br><span class="line">conRAII = *SQL;</span><br><span class="line">poolRAII = connPool;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>connectionRAII::~connectionRAII()</strong></p>
<p><strong>在该类的析构函数中释放该连接，并将其入池。</strong></p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">poolRAII-&gt;<span class="built_in">ReleaseConnection</span>(conRAII);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>使用RAII机制，将外部获取连接封装到类connectionRAII中，这样使用，当该对象声明结束时，编译器会自动调用其析构函数，回收该连接，<strong>避免手动释放</strong></p>
<h1 id="timer"><a href="#timer" class="headerlink" title="timer"></a><strong>timer</strong></h1><p>网络程序通常需要处理定时事件，例如定期检测客户连接的活动状态，因为非活跃连接占用了连接资源，需要定期检测释放非活跃连接。通常将定时事件封装为定时器类，然后使用排序链表、时间轮等数据结构管理定时器。</p>
<p>这里使用<strong>升序链表</strong>实现定时器</p>
<h2 id="变量-2"><a href="#变量-2" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p><strong>struct client_data，连接的相关数据</strong></p>
<p>传递到超时处理函数的参数，主要在多个定时器同时使用时，区别是哪个timer超时。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sockaddr_in address; //连接地址</span><br><span class="line">int sockfd;   //文件描述符</span><br><span class="line">util_timer *timer; //指向连接对应的定时器</span><br></pre></td></tr></table></figure>
</li>
<li><p>time_t expire 超时时间</p>
</li>
<li><p>void ( <em>cb_func</em>*)(*<em>client_data</em> );</p>
<p>回调函数，定时器超时处理函数</p>
</li>
<li><p>util_timer *prev  前继定时器</p>
</li>
<li><p>util_timer *next  后继定时器</p>
</li>
<li><p>util_timer *head;</p>
<p>util_timer *tail;   定时器列表容器的头尾结点</p>
</li>
<li><p>static int *u_pipefd  管道</p>
</li>
<li><p>sort_timer_lst m_timer_lst</p>
</li>
<li><p>static int u_epollfd;</p>
</li>
<li><p>int m_TIMESLOT   闹钟设置的时间</p>
</li>
</ul>
<h2 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p><strong>sort_timer_lst::sort_timer_lst()，定时器容器类的构造函数</strong></p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head = <span class="literal">NULL</span>;</span><br><span class="line">tail = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>添加计时器</strong></p>
<ul>
<li><p><strong>void sort_timer_lst::add_timer(util_timer *timer)</strong></p>
<ul>
<li>定时器按照expire（定时器定时的滴答数）从小到大排序</li>
<li>如果新的定时器超时时间小于当前头部结点，直接将当前定时器结点作为头部节点<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timer-&gt;expire &lt; head-&gt;expire)</span><br><span class="line">   &#123;</span><br><span class="line">     timer-&gt;next = head;</span><br><span class="line">     head-&gt;prev = timer;</span><br><span class="line">     head = timer;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">add_timer</span>(timer, head);<span class="comment">//对于非头结点的计时器</span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>对于不是头结点的定时器，使用c++的优先队列实现定时器，即用<strong>时间堆</strong>的方式实现，如下</p>
</li>
<li><p><strong>void sort_timer_lst::add_timer(util_timer *timer, util_timer *lst_head)</strong></p>
</li>
</ul>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (timer-&gt;expire &lt; tmp-&gt;expire)  <span class="comment">//tmp是头结点的下一结点     </span></span><br><span class="line">&#123;</span><br><span class="line">    prev-&gt;next = timer;</span><br><span class="line">    timer-&gt;next = tmp;</span><br><span class="line">    tmp-&gt;prev = timer;</span><br><span class="line">    timer-&gt;prev = prev;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">prev = tmp;</span><br><span class="line">tmp = tmp-&gt;next;</span><br></pre></td></tr></table></figure>

<p>如果遍历完tmp&#x3D;&#x3D;NULL（！tmp）即定时器的超时时间比最后一个结点还要大，则将要加入的定时器放到尾结点处</p>
</li>
<li><p><strong>void sort_timer_lst::adjust_timer(util_timer *timer)，调整定时器</strong></p>
<p>任务发生变化时，调整定时器在链表中的位置</p>
<ul>
<li>当<strong>被调整的定时器在链表尾部</strong>或者<strong>定时器超时值仍小于下一定时器的超时值</strong>时，不调整</li>
</ul>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">util_timer *tmp = timer-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!tmp || (timer-&gt;expire &lt; tmp-&gt;expire))</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>被调整定时器是链表头结点，将定时器取出，重新插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (timer == head)</span><br><span class="line">&#123;</span><br><span class="line">    head = head-&gt;next;</span><br><span class="line">    head-&gt;prev = NULL;</span><br><span class="line">    timer-&gt;next = NULL;</span><br><span class="line">    add_timer(timer, head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>被调整定时器在内部，将定时器取出，重新插入</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">else</span><br><span class="line">&#123;    </span><br><span class="line">    timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">    timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">    add_timer(timer, timer-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>void sort_timer_lst::del_timer(util_timer *timer)，删除定时器</strong></p>
<ul>
<li><p>结点位置不同，指针的变化不同</p>
<ul>
<li><p>链表中只有一个定时器，需要删除该定时器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if ((timer == head) &amp;&amp; (timer == tail))</span><br><span class="line">&#123;</span><br><span class="line">    delete timer;</span><br><span class="line">    head = NULL;</span><br><span class="line">    tail = NULL;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>被删除的定时器为头结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">head = head-&gt;next;</span><br><span class="line">head-&gt;prev = NULL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>被删除的定时器为尾结点</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tail = tail-&gt;prev;</span><br><span class="line">tail-&gt;next = NULL;</span><br></pre></td></tr></table></figure>
</li>
<li><p>被删除的定时器在链表内部，常规链表结点删除</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>void sort_timer_lst::tick()，定时任务处理</strong></p>
<ul>
<li><p>获取当前时间time_t cur&#x3D;time(NULL)，遍历定时器链表，对应不同的处理方法</p>
</li>
<li><p>当前时间小于定时器时间，后面的定时器也没有到期，直接break，等待时间到了再执行？</p>
</li>
<li><p>当前定时器到期，则调用回调函数，执行定时事件，将处理后的定时器从链表容器中删除，并重置头结点</p>
</li>
</ul>
</li>
<li><p><strong>void cb_func(client_data *user_data)，定时器回调</strong></p>
<ul>
<li><p>删除非活动连接在socket上的注册事件，关闭文件描述符</p>
<p>epoll_ctl  -&gt;  close(user_data-&gt;sockfd)</p>
</li>
<li><p>减少连接数</p>
<p>http_conn::m_user_count–;</p>
</li>
</ul>
</li>
<li><p><strong>void Utils::init(int timeslot)，定时</strong></p>
</li>
<li><p><strong>int Utils::setnonblocking(int fd)，对文件描述符设置非阻塞</strong></p>
<p>要先把fd对应的标志flags读出来，然后加上非阻塞标志O_NONBLOCK，再设置回去</p>
<figure class="highlight cc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL);</span><br><span class="line"><span class="type">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line"><span class="built_in">fcntl</span>(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br></pre></td></tr></table></figure>

<h6 id="补充介绍fcntl"><a href="#补充介绍fcntl" class="headerlink" title="补充介绍fcntl"></a><strong>补充介绍fcntl</strong></h6><p>fcntl()函数，是Linux用来管理文件描述符的API。</p>
<p>读取fd的标志用F_GETFL，设置fd的标志用F_SETFL。</p>
<p>（添加标志用或运算，清除标志用按位取反之后的与运算）</p>
</li>
<li><p><strong>void Utils::addfd(int epollfd, int fd, bool one_shot, int TRIGMode)</strong></p>
<p>将内核事件表注册读事件，ET模式，选择开启<strong>EPOLLONESHOT</strong></p>
</li>
<li><p><strong>void Utils::sig_handler(int sig)，事件处理</strong></p>
<p>为保证函数的可重入性，保留原来的error</p>
<p>将信号值从管道写端写入，使用send</p>
</li>
<li><p>send(u_pipefd[1], (char *)&amp;msg, 1, 0);<strong>void Utils::addsig(int sig, void(handler)(int), bool restart)，设置信号</strong></p>
<h6 id="补充介绍-struct-sigaction结构体-和-函数-memset、-sigfillset、sigaction"><a href="#补充介绍-struct-sigaction结构体-和-函数-memset、-sigfillset、sigaction" class="headerlink" title="补充介绍  struct sigaction结构体 和 函数 memset、 sigfillset、sigaction"></a>补充介绍  struct sigaction结构体 和 函数 memset、 sigfillset、sigaction</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct sigaction &#123;</span><br><span class="line">   void (*sa_handler)(int);</span><br><span class="line">   void (*sa_sigaction)(int, siginfo_t *, void *);</span><br><span class="line">   sigset_t sa_mask;</span><br><span class="line">   int sa_flags;</span><br><span class="line">   void (*sa_restorer)(void);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sa_handler代表新的信号处理函数，<strong>仅仅发送信号值，不做对应逻辑处理</strong></p>
</li>
<li><p>sa_mask 用来设置在处理该信号时暂时将sa_mask 指定的信号集搁置</p>
</li>
<li><p>sa_flags 用来设置信号处理的其他相关操作，下列的数值可用。 </p>
</li>
<li><p>SA_RESETHAND：当调用信号处理函数时，将信号的处理函数重置为缺省值SIG_DFL</p>
</li>
<li><p>SA_RESTART：如果信号中断了进程的某个系统调用，则系统自动启动该系统调用</p>
</li>
<li><p>SA_NODEFER ：一般情况下， 当信号处理函数运行时，内核将阻塞该给定信号。但是如果设置了 SA_NODEFER标记， 那么在该信号处理函数运行时，内核将不会阻塞该信号</p>
</li>
<li><p>memset函数为初始化函数，可以将一段<strong>连续的内存初始化</strong>为某个值。<strong>但它是以字节为单位进行初始化的。</strong></p>
</li>
<li><p>sigfillset函数将所有的信号都添加到信号集中。</p>
</li>
<li><p>sigaction函数的功能是检查或修改与指定信号相关联的处理动作（可同时两种操作）</p>
</li>
</ul>
</li>
<li><p><strong>void Utils::timer_handler()</strong></p>
<ul>
<li><p>调用tick定时处理任务</p>
</li>
<li><p>利用alarm函数重新定时以不断触发SIGALRM信号</p>
<h6 id="补充介绍alarm函数"><a href="#补充介绍alarm函数" class="headerlink" title="补充介绍alarm函数"></a><strong>补充介绍alarm函数</strong></h6><p>alarm函数是设置一个计时器, 在计时器超时的时候, 产生SIGALRM信号。</p>
<p>它的主要功能是设置信号传送闹钟。其主要功能用来设置信号SIGALRM在经过seconds指定的秒数后传送给目前的进程，如果在定时未完成的时间内再次调用了alarm函数，则后一次定时器设置将覆盖前面的设置，当seconds设置为0时，定时器将被取消。它返回上次定时器剩余时间，如果是第一次设置则返回0。</p>
</li>
</ul>
</li>
</ul>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><img src="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/timer.png" alt="timer"></p>
<ul>
<li><p>创建定时器时需要先定义users_timer &#x3D; new client_data[MAX_FD]</p>
</li>
<li><p>初始化定时器init_timer</p>
</li>
<li><p>在超时处理函数结尾重新加载定时器时间adjust_timer</p>
</li>
<li><p>如果自己编写的驱动中有中断，需要在中断入口处del_timer，并且在入口处重新重新加载定时器时间adjust_timer</p>
</li>
</ul>
<h1 id="http"><a href="#http" class="headerlink" title="http"></a>http</h1><p><img src="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/_3cBGoX9chIM3H0t1oHRmg.jpeg" alt="img">        </p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>● 连接处理：浏览器端发出http连接请求，主线程创建http对象接收请求并将所有数据读入对应buffer，将该对象插入任务队列，等待工作线程从任务队列中取出一个任务进行处理。<br>● 处理报文请求：工作线程取出任务后，调用进程处理函数，通过主、从状态机对请求报文进行解析。<br>● 返回响应报文：解析完之后，生成响应报文，返回给浏览器端。</p>
<p>READ_BUFFER_SIZE: 读取缓冲区大小</p>
<p>WRITE_BUFFER_SIZE: 写入缓冲区大小</p>
<p><strong>enum</strong>:	enum是<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/5581937">计算机编程语言</a>中的一种数据类型。枚举类型：在实际问题中，有些变量的取值被限定在一个有限的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%8C%83%E5%9B%B4/33207">范围</a>内。例如，一个星期内只有七天，一年只有十二个月，一个班每周有六门课程等等。如果把这些量说明为<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B4%E5%9E%8B/4813071">整型</a>，字符型或其它类型显然是不<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E5%A6%A5%E5%BD%93/10959259">妥当</a>的。为此，C语言提供了一种称为“枚举”的类型。在“枚举”类型的定义中列举出所有可能的取值，被说明为该“枚举”类型的变量取值不能超过定义的范围。应该说明的是，枚举类型是一种基本数据类型，而不是一种构造类型，因为它不能再分解为任何基本类型。</p>
<p><strong>METHOD</strong>:枚举可能出现的连接的方法</p>
<p><strong>CHECK_STATE</strong>: ?	</p>
<p>​                 <img src="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/qNoC_XNdEYo2n6CXbUau9A.png" alt="img">        </p>
<p><strong>HTTP_CODE</strong>: 判断请求是什么？</p>
<p><strong>LIME_STATUS</strong>：线路状态：OK,BAD,OPEN</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><h3 id="EPOLL-文件监听事件"><a href="#EPOLL-文件监听事件" class="headerlink" title="EPOLL: 文件监听事件"></a>EPOLL: 文件监听事件</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xuewangkai/p/11158576.html">epoll使用详解：epoll_create、epoll_ctl、epoll_wait、close - 雾穹 - 博客园 (cnblogs.com)</a></p>
<h3 id="HTTP-状态信息定义"><a href="#HTTP-状态信息定义" class="headerlink" title="HTTP 状态信息定义"></a>HTTP 状态信息定义</h3><p>const char *ok_200_title &#x3D; “OK”;</p>
<p>const char *error_400_title &#x3D; “Bad Request”;</p>
<p>const char *error_400_form &#x3D; “Your request has bad syntax or is inherently impossible to staisfy.\n”;</p>
<p>const char *error_403_title &#x3D; “Forbidden”;</p>
<p>const char *error_403_form &#x3D; “You do not have permission to get file form this server.\n”;</p>
<p>const char *error_404_title &#x3D; “Not Found”;</p>
<p>const char *error_404_form &#x3D; “The requested file was not found on this server.\n”;</p>
<p>const char *error_500_title &#x3D; “Internal Error”;</p>
<p>const char *error_500_form &#x3D; “There was an unusual problem serving the request file.\n”;</p>
<h2 id="HTTP逻辑框架"><a href="#HTTP逻辑框架" class="headerlink" title="HTTP逻辑框架"></a>HTTP逻辑框架</h2><p>​                 <img src="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/Y_q6fzTjkIOcLxlFm3x3Rg.png" alt="img">        </p>
<h2 id="变量-3"><a href="#变量-3" class="headerlink" title="变量"></a>变量</h2><p>   static const int FILENAME_LEN &#x3D; 200;&#x2F;&#x2F;设置读取文件的名称m_real_file大小</p>
<p>​    static const int READ_BUFFER_SIZE &#x3D; 2048;&#x2F;&#x2F;设置读缓冲区m_read_buf大小</p>
<p>​    static const int WRITE_BUFFER_SIZE &#x3D; 1024; &#x2F;&#x2F;设置写缓冲区m_write_buf大小</p>
<p>   char m_read_buf[READ_BUFFER_SIZE];&#x2F;&#x2F;存储读取的请求报文数据</p>
<p>​    int m_read_idx;&#x2F;&#x2F;缓冲区中m_read_buf中数据的最后一个字节的下一个位置</p>
<p>​    int m_checked_idx;&#x2F;&#x2F;m_read_buf读取的位置</p>
<p>​    int m_start_line;&#x2F;&#x2F;m_read_buf中已经解析的字符个数</p>
<p>​    char m_write_buf[WRITE_BUFFER_SIZE];&#x2F;&#x2F;存储发出的响应报文数据</p>
<p>​    int m_write_idx;&#x2F;&#x2F;指示buffer中的长度</p>
<p>​    CHECK_STATE m_check_state;  &#x2F;&#x2F;主状态机状态</p>
<p>​    METHOD m_method;&#x2F;&#x2F;请求的方法</p>
<p>​    char m_real_file[FILENAME_LEN]; &#x2F;&#x2F;文件目录？</p>
<p>​    char *m_url;               &#x2F;&#x2F;报文的url</p>
<p>​    char *m_version;           &#x2F;&#x2F;报文的http协议类型</p>
<p>​    char *m_host;			   &#x2F;&#x2F;报文的host</p>
<p>​    int m_content_length;      &#x2F;&#x2F;消息体长度</p>
<p>​    bool m_linger;</p>
<p>​    char *m_file_address;  &#x2F;&#x2F;读取服务器上的文件地址</p>
<p>​    struct iovec m_iv[2];&#x2F;&#x2F;io向量机制iovec</p>
<p>​    int cgi;        &#x2F;&#x2F;是否启用的POST</p>
<p>​    char *m_string; &#x2F;&#x2F;存储请求头数据</p>
<p>​    int bytes_to_send;&#x2F;&#x2F;剩余发送字节数</p>
<p>​    int bytes_have_send;&#x2F;&#x2F;已发送字节数</p>
<h2 id="函数-3"><a href="#函数-3" class="headerlink" title="函数"></a>函数</h2><p><strong>initmysql_result()</strong></p>
<p>void http_conn::initmysql_result(connection_pool *connPool)先从连接池取出一个连接</p>
<p>connectionRAII mysqlcon(&amp;mysql, connPool);<strong>setnonblocking()</strong></p>
<p>对文件描述符设置非堵塞</p>
<p>阻塞操作：</p>
<p>​     是指在执行设备操作时，若不能获得资源则挂起进程，直到满足可操作的条件后进行操作，</p>
<p>​     被挂起的进程进入睡眠状态，被从调度器的运行队列移走，直到等待的条件被满足.</p>
<p>非阻塞操作：</p>
<p>​     进程不能进行设备操作时并不挂起，他或者<strong>放弃，或者不停的查询</strong>，直到可以进行操作为止.</p>
<p><strong>addfd()</strong></p>
<p>将内核事件表注册读事件，ET模式，选择开启EPOLLONESHOT</p>
<p>epoll_event event;</p>
<p>event.data.fd &#x3D; fd;创造一个事件</p>
<p>if (1 &#x3D;&#x3D; TRIGMode)</p>
<p>​     event.events &#x3D; EPOLLIN | EPOLLET | EPOLLRDHUP;</p>
<p>   else</p>
<p>​     event.events &#x3D; EPOLLIN | EPOLLRDHUP;</p>
<p>   if (one_shot)</p>
<p>​     event.events |&#x3D; EPOLLONESHOT;设置文件描述符		</p>
<p>EPOLLIN：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）</p>
<ul>
<li><p>EPOLLOUT：表示对应的文件描述符可以写</p>
</li>
<li><p>EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）</p>
</li>
<li><p>EPOLLERR：表示对应的文件描述符发生错误</p>
</li>
<li><p>EPOLLHUP：表示对应的文件描述符被挂断；</p>
</li>
<li><p>EPOLLET：将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)而言的</p>
</li>
<li><p>EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</p>
</li>
<li><p>epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</p>
<p>setnonblocking(fd);</p>
</li>
<li><p>(注册新的fd到epfd)，对文件描述符设置非堵塞态</p>
</li>
</ul>
<p><strong>removefd()</strong></p>
<p>从内核时间表删除描述符</p>
<p><strong>modfd()</strong></p>
<p>将事件重置为EPOLLONESHOT</p>
<p>if (1 &#x3D;&#x3D; TRIGMode)</p>
<p>​     event.events &#x3D; ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</p>
<p>   else</p>
<p>event.events &#x3D; ev | EPOLLONESHOT | EPOLLRDHUP;</p>
<p><strong>http_conn::close_conn（）</strong></p>
<p>关闭连接，关闭一个连接，客户总量减一</p>
<p><strong>http_conn::init(int sockfd, const sockaddr_in &amp;addr, char *root, int TRIGMode,int close_log, string user, string passwd, string sqlname)</strong></p>
<p>初始化连接，外部调用初始化套接字地址</p>
<p><strong>http_conn::init()</strong></p>
<p>初始化新接受的连接，check_state默认为分析请求行状态</p>
<p><strong>http_conn::LINE_STATUS http_conn::parse_line()</strong></p>
<p>从状态机，用于分析出一行内容，返回值为行的读取状态，有LINE_OK,LINE_BAD,LINE_OPEN</p>
<p>if (temp &#x3D;&#x3D; ‘\r’)</p>
<p>​     {</p>
<p>​       if ((m_checked_idx + 1) &#x3D;&#x3D; m_read_idx)</p>
<p>​         return LINE_OPEN;</p>
<p>如果当前是\r字符，则有可能会读取到完整行，下一个字符达到了buffer结尾，则接收不完整，需要继续接收</p>
<p> else if (m_read_buf[m_checked_idx + 1] &#x3D;&#x3D; ‘\n’)</p>
<p>​       {</p>
<p>​         m_read_buf[m_checked_idx++] &#x3D; ‘\0’;</p>
<p>​         m_read_buf[m_checked_idx++] &#x3D; ‘\0’;</p>
<p>​         return LINE_OK;</p>
<p>}下一个字符是\n，将\r\n改为\0\0</p>
<p>都不符合则返回语法错误，<strong>LINE_BAD</strong></p>
<p>else if (temp &#x3D;&#x3D; ‘\n’)</p>
<p>​     {</p>
<p>​       &#x2F;&#x2F;前一个字符是\r，则接收完整</p>
<p>​       if (m_checked_idx &gt; 1 &amp;&amp; m_read_buf[m_checked_idx - 1] &#x3D;&#x3D; ‘\r’)</p>
<p>​       {</p>
<p>​         m_read_buf[m_checked_idx - 1] &#x3D; ‘\0’;</p>
<p>​         m_read_buf[m_checked_idx++] &#x3D; ‘\0’;</p>
<p>​         return LINE_OK;</p>
<p>​       }</p>
<p>​       return LINE_BAD;</p>
<p>​     }</p>
<p>   }</p>
<p>   &#x2F;&#x2F;并没有找到\r\n，需要继续接收</p>
<p>   return LINE_OPEN;如果当且字符是\n的处理方法</p>
<p><strong>http_conn::read_once()</strong></p>
<p>循环读取客户数据，直到无数据可读或对方关闭连接,非阻塞ET工作模式下，需要一次性将数据读完</p>
<p><strong>http_conn::HTTP_CODE http_conn::parse_request_line(char *text)</strong></p>
<p>解析http请求行，获得请求方法，目标url及http版本号</p>
<ul>
<li>主状态机的初始状态，调用parse_request_line函数解析请求行</li>
<li>解析函数从m_read_buf中解析HTTP请求行，获得请求方法、目标URL及HTTP版本号</li>
<li>解析完成后主状态机的状态变为CHECK_STATE_HEADER</li>
</ul>
<p>m_url &#x3D; strpbrk(text, “ \t”);请求行中最先含有空格和\t任一字符的位置并返回，如果没有目标字符则表示报文格式有问题，return <strong>BAD_REQUEST</strong></p>
<p>*m_url++ &#x3D; ‘\0’;用于将前面的数据取出</p>
<p>char *method &#x3D; text;</p>
<p>   if (strcasecmp(method, “GET”) &#x3D;&#x3D; 0)</p>
<p>​     m_method &#x3D; GET;</p>
<p>   else if (strcasecmp(method, “POST”) &#x3D;&#x3D; 0)</p>
<p>   {</p>
<p>​     m_method &#x3D; POST;</p>
<p>​     cgi &#x3D; 1;</p>
<p>   }</p>
<p>   else</p>
<p>​     return BAD_REQUEST;</p>
<p>取出数据确定请求方式</p>
<p> m_url +&#x3D; strspn(m_url, “ \t”);m_url此时跳过了第一个空格或者\t字符，但是后面还可能存在  不断后移找到请求资源的第一个字符</p>
<p>if (strcasecmp(m_version, “HTTP&#x2F;1.1”) !&#x3D; 0)</p>
<p>​     return BAD_REQUEST;目前仅支持http1.1</p>
<p>if (strncasecmp(m_url, “http:&#x2F;&#x2F;“, 7) &#x3D;&#x3D; 0)</p>
<p>   {</p>
<p>​     m_url +&#x3D; 7;</p>
<p>​     m_url &#x3D; strchr(m_url, ‘&#x2F;‘);</p>
<p>   }对请求资源的前七个字符进行判断    对某些带有http:&#x2F;&#x2F;的报文进行单独处理</p>
<p><strong>http_conn::HTTP_CODE http_conn::parse_header(char*text)</strong></p>
<p>解析http请求的一个头部信息</p>
<ul>
<li>调用parse_headers函数解析请求头部信息</li>
<li>判断是空行还是请求头，若是空行，进而判断content-length是否为0，如果不是0，表明是POST请求，则状态转移到CHECK_STATE_CONTENT，否则说明是GET请求，则报文解析结束。</li>
<li>若解析的是请求头部字段，则主要分析connection字段，content-length字段，其他字段可以直接跳过，各位也可以根据需求继续分析。</li>
<li>connection字段判断是keep-alive还是close，决定是长连接还是短连接</li>
<li>content-length字段，这里用于读取post请求的消息体长度</li>
</ul>
<p>m_check_state &#x3D; CHECK_STATE_CONTENT;</p>
<p>​       return NO_REQUEST;</p>
<ul>
<li>post请求需要改变主状态机的状态</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">else if (strncasecmp(text, &quot;Connection:&quot;, 11) == 0)</span><br><span class="line">&#123;</span><br><span class="line">    text += 11;</span><br><span class="line">    //跳过空格和\t字符</span><br><span class="line">    text += strspn(text, &quot; \t&quot;);</span><br><span class="line">    if (strcasecmp(text, &quot;keep-alive&quot;) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">    //判断是否为长连接</span><br><span class="line">    m_linger = true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;解析头部连接字段</span><br><span class="line">else if (strncasecmp(text, &quot;Content-length:&quot;, 15) == 0)</span><br><span class="line">&#123;</span><br><span class="line">    text += 15;</span><br><span class="line">    text += strspn(text, &quot; \t&quot;);</span><br><span class="line">    m_content_length = atol(text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析请求头 内容长度字段</p>
<p><strong>http_conn::HTTP_CODE http_conn::parse_content(char *text)</strong></p>
<ul>
<li>仅用于解析POST请求，调用parse_content函数解析消息体</li>
<li>用于保存POST请求消息体，为后面的登陆和注册做准备</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (m_read_idx &gt;= (m_content_length + m_checked_idx))</span><br><span class="line">&#123;</span><br><span class="line">    text[m_content_length] = &#x27;\0&#x27;;</span><br><span class="line">    //POST请求中最后为输入的用户名和密码</span><br><span class="line">    m_string = text;</span><br><span class="line">    return GET_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line">return NO_REQUEST;判断是否读取了消息体</span><br></pre></td></tr></table></figure>



<p><strong>http_conn::HTTP_CODE http_conn::process_read()</strong></p>
<p>process_read返回值是对请求文件的分析结果，一部分是语法错误的BAD_REQUEST，一部分则是我们认可的规则然后作出的对应的响应</p>
<p>主状态机初始状态是CHECK_STATE_REQUESTLINE，通过调用从状态机来驱动主状态机</p>
<p>从状态机以及将每一行的末尾\r\n符号改为\0\0，主状态机直接去除对应字符串进行处理</p>
<p>LINE_STATUS line_status &#x3D; LINE_OK;</p>
<p>HTTP_CODE ret &#x3D; NO_REQUEST;</p>
<p>char *text &#x3D; 0;初始化从状态机的状态</p>
<p>ret &#x3D; parse_request_line(text);</p>
<p>ret &#x3D; parse_headers(text)</p>
<p>ret &#x3D; parse_content(text);三种状态转换逻辑，分别解析请求行，解析请求头，解析消息体</p>
<p>else if (ret &#x3D;&#x3D; GET_REQUEST)</p>
<p>​       {</p>
<p>​         return do_request();</p>
<p>​       }如果是get请求则需要跳转到报文响应函数</p>
<p>如果是post请求，跳转到报文响应函数，更新并跳出循环，维持line_open的状态</p>
<p><strong>http_conn::HTTP_CODE http_conn::do_request()</strong></p>
<p>strcpy(m_real_file, doc_root);</p>
<p>int len &#x3D; strlen(doc_root);将初始化的m_real_file赋值为网站根目录</p>
<p>const char *p &#x3D; strrchr(m_url, ‘&#x2F;‘);找到m_url中&#x2F;的位置</p>
<p><strong>void http_conn::unmap()</strong></p>
<p><strong>bool http_conn::write()</strong></p>
<p>​                 <img src="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/F1wM4YgOsLk5Bs0MASW3vQ.png" alt="img">        </p>
<p><strong>bool http_conn::process_write(HTTP_CODE ret)</strong></p>
<p><strong>void http_conn::process()</strong></p>
<p>if (read_ret &#x3D;&#x3D; NO_REQUEST)</p>
<p>   {</p>
<p>​     &#x2F;&#x2F;注册并监听读事件</p>
<p>​     modfd(m_epollfd, m_sockfd, EPOLLIN, m_TRIGMode);</p>
<p>​     return;</p>
<p>   }NO_REQUEST，表示请求不完整，需要继续接收请求数据</p>
<p>bool write_ret &#x3D; process_write(read_ret);</p>
<p>   if (!write_ret)</p>
<p>   {</p>
<p>​     close_conn();</p>
<p>   }</p>
<p>如果接受到了数据则调用process_write完成报文响应</p>
<p>modfd(m_epollfd, m_sockfd, EPOLLOUT, m_TRIGMode);</p>
<p>注册并监听事件</p>
<h1 id="threadpool"><a href="#threadpool" class="headerlink" title="threadpool"></a>threadpool</h1><h2 id="整体框架"><a href="#整体框架" class="headerlink" title="整体框架"></a>整体框架</h2><p>​                 <img src="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/x7mZnDY4r5Xrtu0LzAP2dg.png" alt="img">        </p>
<h2 id="变量-4"><a href="#变量-4" class="headerlink" title="变量"></a>变量</h2><ul>
<li><p>m_thread_number  线程池中线程的数量</p>
</li>
<li><p>m_max_requests  请求队列中最多允许的、等待处理的请求的数量</p>
</li>
<li><p>m_threads 描述线程池的数组，其大小为m_thread_number</p>
</li>
</ul>
<p>m_threads &#x3D; new pthread_t[m_thread_number];</p>
<ul>
<li>sem m_queuestat; 是否有任务需要处理</li>
<li>locker m_queuelocker；  保护请求队列的互斥锁</li>
<li>std::list&lt;T *&gt; m_workqueue  请求队列</li>
<li>connection_pool *m_connPool  数据库</li>
<li>m_actor_model  模型切换</li>
</ul>
<h2 id="函数-4"><a href="#函数-4" class="headerlink" title="函数"></a>函数</h2><ul>
<li><p>threadpool（）线程池构造函数</p>
</li>
<li><ul>
<li>循环创建线程</li>
</ul>
</li>
</ul>
<p>pthread_create(m_threads + i, NULL, worker, this) !&#x3D; 0</p>
<p>​       创建成功应该返回0，如果线程池在线程创建阶段就失败，那就应该关闭线程池了</p>
<ul>
<li><ul>
<li><p>更改线程属性为unjoinable，分离线程</p>
</li>
<li><ul>
<li>pthread_detach(m_threads[i]);</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>创建一个线程之后需要调用pthread_detech(),原因在于： linux线程有两种状态<strong>joinable状态和unjoinable状态。</strong></p>
<ul>
<li><ul>
<li><ul>
<li>当线程为joinable状态，线程函数退出<strong>都不会释放线程所占用堆栈和线程描述符</strong>。只有当调用了pthread_join，<strong>主线程阻塞等待子线程结束</strong>，才会回收子线程资源。</li>
<li>unjoinable属性可以在pthread_create时指定，或在线程创建后在线程中pthread_detach，<strong>主线程与子线程分离</strong>，<strong>子线程结束后，资源自动回收</strong></li>
</ul>
</li>
</ul>
</li>
<li><p>append_p(）Proactor模式下的任务请求入队</p>
</li>
<li><ul>
<li><p>当epoll检测到端口有事件激活时，即将该事件放入请求队列中，并注意互斥，等待工作线程处理 </p>
</li>
<li><p>本项目所实现的是一个基于半同步&#x2F;半反应堆式的并发结构，以Proactor模式为例的工作流程</p>
</li>
<li><p>主线程充当异步线程，负责监听所有socket上的事件</p>
</li>
<li><ul>
<li>若有新请求到来，主线程接收之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件</li>
<li>如果连接socket上有读写事件发生，主线程从socket上接收数据，并将数据封装成请求对象插入到请求队列中</li>
<li>所有<strong>工作线程睡眠在请求队列上</strong>，当有任务到来时，通过竞争（如互斥锁）获得任务的接管权</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​                 <img src="http://hexo-git.oss-cn-beijing.aliyuncs.com/img/EoV7MwhIAGlLh9KKOhCTyw.png" alt="img">        </p>
<ul>
<li><p>worker(）线程回调函数</p>
</li>
<li><ul>
<li>template <typename T></li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  void *threadpool&lt;T&gt;::worker(void *arg)</span><br><span class="line"></span><br><span class="line">   		&#123;</span><br><span class="line"></span><br><span class="line">  	  //调用时 *arg是this！</span><br><span class="line"></span><br><span class="line">//将参数强转为线程池类，调用成员方法，获取threadpool对象地址</span><br><span class="line"></span><br><span class="line">  	  threadpool *pool = (threadpool *)arg;</span><br><span class="line"></span><br><span class="line">   	//线程池中每一个线程创建时都会调用run()，睡眠在队列中</span><br><span class="line"></span><br><span class="line">  		 pool-&gt;run();</span><br><span class="line"></span><br><span class="line">   	return pool;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><p>run（）</p>
</li>
<li><ul>
<li>看作一个回环事件：等待m_queuestat()信号变量post，即新任务进入请求队列，然后就加锁取任务-&gt;取到任务解锁-&gt;执行任务</li>
<li>从请求队列中取出第一个任务，将任务从请求队列删除</li>
<li>每调用一次pthread_create就会调用一次run(),因为每个线程是相互独立的，<strong>都睡眠在工作队列上，仅当信号变量更新才会唤醒进行任务的竞争</strong>。</li>
</ul>
</li>
</ul>
<p>​			</p>
<h1 id="lock"><a href="#lock" class="headerlink" title="lock"></a>lock</h1><p>为便于实现同步类的RAII机制，该项目在pthread库的基础上进行了封装</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><ul>
<li>#include &lt;semaphore.h&gt;    POSIX信号量</li>
<li>#include &lt;pthread.h&gt;   互斥锁 与条件变量</li>
</ul>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><ul>
<li>sem  简单的信号量类，包括对信号量的构造与析构和wait与post的设置</li>
<li>locker 简单的互斥锁类，包括对互斥锁的构造与析构和加锁与解锁的设置</li>
<li>cond  简单的条件变量类，包含对条件变量的构造与析构和wait、timewait、signal、broadcast的设置</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/05/30/university/%E8%AE%A1%E7%BD%91/%E8%AE%A1%E7%BD%91chp3-%E4%BC%A0%E8%BE%93%E5%B1%82/" rel="prev" title="计网chp3-传输层">
      <i class="fa fa-chevron-left"></i> 计网chp3-传输层
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/06/07/university/%E8%AE%A1%E7%BD%91/tinywebserver-%E5%AE%9E%E6%88%98/" rel="next" title="tinywebserver-实战">
      tinywebserver-实战 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80%E4%BA%9B%E6%A6%82%E5%BF%B5"><span class="nav-number">1.</span> <span class="nav-text">一些概念</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.1.</span> <span class="nav-text">触发模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#IO%E5%A4%8D%E7%94%A8"><span class="nav-number">1.2.</span> <span class="nav-text">IO复用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="nav-number">1.3.</span> <span class="nav-text">事件处理模式</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#main-WebServer"><span class="nav-number">2.</span> <span class="nav-text">main+WebServer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text">常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0"><span class="nav-number">2.3.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="nav-number">2.4.</span> <span class="nav-text">流程图</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#CGImysql"><span class="nav-number">3.</span> <span class="nav-text">CGImysql</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A8%A1%E5%9D%97%E9%80%BB%E8%BE%91%EF%BC%9A%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-RAII%E6%9C%BA%E5%88%B6"><span class="nav-number">3.1.</span> <span class="nav-text">模块逻辑：单例模式&amp;RAII机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F-1"><span class="nav-number">3.2.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-1"><span class="nav-number">3.3.</span> <span class="nav-text">函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#timer"><span class="nav-number">4.</span> <span class="nav-text">timer</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F-2"><span class="nav-number">4.1.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-2"><span class="nav-number">4.2.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95"><span class="nav-number">4.3.</span> <span class="nav-text">使用方法</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#http"><span class="nav-number">5.</span> <span class="nav-text">http</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AD%A5%E9%AA%A4"><span class="nav-number">5.1.</span> <span class="nav-text">步骤</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A6%82%E5%BF%B5"><span class="nav-number">5.2.</span> <span class="nav-text">概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#EPOLL-%E6%96%87%E4%BB%B6%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6"><span class="nav-number">5.2.1.</span> <span class="nav-text">EPOLL: 文件监听事件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HTTP-%E7%8A%B6%E6%80%81%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%B9%89"><span class="nav-number">5.2.2.</span> <span class="nav-text">HTTP 状态信息定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#HTTP%E9%80%BB%E8%BE%91%E6%A1%86%E6%9E%B6"><span class="nav-number">5.3.</span> <span class="nav-text">HTTP逻辑框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F-3"><span class="nav-number">5.4.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-3"><span class="nav-number">5.5.</span> <span class="nav-text">函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#threadpool"><span class="nav-number">6.</span> <span class="nav-text">threadpool</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B4%E4%BD%93%E6%A1%86%E6%9E%B6"><span class="nav-number">6.1.</span> <span class="nav-text">整体框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%98%E9%87%8F-4"><span class="nav-number">6.2.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-4"><span class="nav-number">6.3.</span> <span class="nav-text">函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#lock"><span class="nav-number">7.</span> <span class="nav-text">lock</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8"><span class="nav-number">7.1.</span> <span class="nav-text">引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">7.2.</span> <span class="nav-text">类</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Sean"
      src="/images/banner.jpg">
  <p class="site-author-name" itemprop="name">Sean</p>
  <div class="site-description" itemprop="description">热爱可抵岁月漫长</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">98</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Seanxz401" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Seanxz401" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Sean</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
